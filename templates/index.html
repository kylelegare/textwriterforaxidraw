<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>AxiDraw Postcard Writer</title>
  <!-- Bootstrap CSS (optional) -->
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
    rel="stylesheet"
  />
  <style>
    /* Include your custom font. Adjust URL/path if needed. */
    @font-face {
      font-family: 'PremiumUltra';
      src: url('/static/fonts/PremiumUltra54.ttf') format('truetype');
    }

    #previewCanvas {
      width: 100%;
      height: auto;
      border: 1px solid var(--bs-border-color);
      background-color: white;
    }

    #fontSizeValue {
      display: inline-block;
      min-width: 40px;
      text-align: right;
    }
  </style>
</head>
<body>
  <div class="container py-4">
    <div class="row">
      <!-- Left side: Preview -->
      <div class="col-md-8">
        <div class="card mb-4">
          <div class="card-header">
            <h5 class="card-title mb-0">Postcard Preview</h5>
          </div>
          <div class="card-body">
            <canvas id="previewCanvas"></canvas>
          </div>
        </div>
      </div>

      <!-- Right side: Controls -->
      <div class="col-md-4">
        <div class="card">
          <div class="card-header">
            <h5 class="card-title mb-0">Controls</h5>
          </div>
          <div class="card-body">
            <div class="mb-3">
              <label for="messageText" class="form-label">Message</label>
              <!-- Removed maxlength to allow longer input -->
              <textarea
                class="form-control"
                id="messageText"
                rows="5"
                placeholder="Enter your message..."
              ></textarea>
            </div>

            <div class="mb-3">
              <label for="fontSize" class="form-label">Preview Size</label>
              <input
                type="range"
                class="form-range"
                id="fontSize"
                min="8"
                max="36"
                value="12"
              />
              <span id="fontSizeValue">12</span>
            </div>

            <div class="mb-3">
              <button id="plotBtn" class="btn btn-primary w-100">
                Plot Message
              </button>
            </div>
          </div>
        </div>

        <div class="card mt-4">
          <div class="card-header">
            <h5 class="card-title mb-0">Status</h5>
          </div>
          <div class="card-body">
            <div id="statusMessage" class="alert alert-info">Ready</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- JavaScript -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Dimensions for AxiDraw Mini in mm
      const AXIDRAW_WIDTH_MM = 152.4;
      const AXIDRAW_HEIGHT_MM = 101.6;
      // Convert mm to px at ~96DPI
      const MM_TO_PX = 3.7795275591;

      // We'll store the text layout here: array of {char, x, y} in px
      let layoutData = [];

      const canvas = document.getElementById('previewCanvas');
      // Set canvas pixel dimensions
      canvas.width = AXIDRAW_WIDTH_MM * MM_TO_PX;   
      canvas.height = AXIDRAW_HEIGHT_MM * MM_TO_PX; 

      const ctx = canvas.getContext('2d');

      const messageText = document.getElementById('messageText');
      const fontSizeRange = document.getElementById('fontSize');
      const fontSizeValue = document.getElementById('fontSizeValue');
      const plotBtn = document.getElementById('plotBtn');
      const statusMessage = document.getElementById('statusMessage');

      // Offscreen canvas for measuring
      const offscreenCanvas = document.createElement('canvas');
      const offscreenCtx = offscreenCanvas.getContext('2d');

      fontSizeRange.addEventListener('input', () => {
        fontSizeValue.textContent = fontSizeRange.value;
        updatePreview();
      });

      messageText.addEventListener('input', updatePreview);

      // MAIN PREVIEW UPDATE
      function updatePreview() {
        // Clear preview
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw bounding rectangle (safe margin)
        // Let's do 10 mm margin => 10 * MM_TO_PX
        const marginPx = 10 * MM_TO_PX;
        ctx.strokeStyle = '#ddd';
        ctx.strokeRect(
          marginPx,
          marginPx,
          canvas.width - 2 * marginPx,
          canvas.height - 2 * marginPx
        );

        // Compute text layout in px
        layoutData = computeLayout(
          messageText.value,
          parseInt(fontSizeRange.value),
          marginPx,
          marginPx,
          canvas.width - 2 * marginPx
        );

        // Render it on the main canvas
        renderPreview(layoutData, parseInt(fontSizeRange.value));
      }

      /**
       * Word-wrap the text to fit maxWidthPx, returning array of {char, x, y}
       */
      function computeLayout(text, fontSizePx, startX, startY, maxWidthPx) {
        offscreenCtx.font = `${fontSizePx}px PremiumUltra`;
        offscreenCtx.textBaseline = 'top';

        // Split on ANY whitespace
        const words = text.split(/\s+/);
        const lineSpacing = fontSizePx * 1.2;

        let x = startX;
        let y = startY;
        let layout = [];
        let currentLine = [];
        let currentLineWidth = 0;
        const spaceWidth = offscreenCtx.measureText(' ').width;

        // Build lines
        for (let i = 0; i < words.length; i++) {
          const w = words[i];
          const wWidth = offscreenCtx.measureText(w).width;
          let needed = (currentLine.length > 0 ? spaceWidth : 0) + wWidth;

          // If adding this word exceeds max line width => break line
          if (currentLineWidth + needed > maxWidthPx && currentLine.length > 0) {
            // Lay out the current line
            layout.push(...layoutLine(currentLine.join(' '), offscreenCtx, fontSizePx, x, y, startX));
            // Move down one line
            y += lineSpacing;
            currentLine = [w];
            currentLineWidth = wWidth;
            x = startX + wWidth;  // track the end of the word
          } else {
            // Continue current line
            currentLine.push(w);
            currentLineWidth += needed;
            x = startX + currentLineWidth;
          }
        }

        // Last line
        if (currentLine.length > 0) {
          layout.push(...layoutLine(currentLine.join(' '), offscreenCtx, fontSizePx, x, y, startX));
        }

        return layout;
      }

      /**
       * Convert a string into array of {char, x, y}.
       * We'll do left-to-right placement, top-based textBaseline.
       */
      function layoutLine(lineText, measureCtx, fontSizePx, endX, baselineY, lineStartX) {
        const results = [];
        let xCursor = lineStartX; 
        for (let i = 0; i < lineText.length; i++) {
          const ch = lineText[i];
          const chW = measureCtx.measureText(ch).width;
          // Place the char at (xCursor, baselineY)
          results.push({
            char: ch,
            x: xCursor,
            y: baselineY
          });
          xCursor += chW;
        }
        return results;
      }

      /**
       * Render the layout on previewCanvas
       */
      function renderPreview(layout, fontSizePx) {
        ctx.fillStyle = 'black';
        ctx.font = `${fontSizePx}px PremiumUltra`;
        ctx.textBaseline = 'top';

        layout.forEach(item => {
          ctx.fillText(item.char, item.x, item.y);
        });
      }

      /**
       * On "Plot Message", send layout to server
       */
      plotBtn.addEventListener('click', async () => {
        try {
          plotBtn.disabled = true;
          statusMessage.className = 'alert alert-info';
          statusMessage.textContent = 'Plotting...';

          const response = await fetch('/api/test_plot', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              layout: layoutData,
              fontSizePx: parseInt(fontSizeRange.value)
            }),
          });

          const data = await response.json();
          if (data.status === 'success') {
            statusMessage.className = 'alert alert-success';
            statusMessage.textContent = 'Plot completed!';
          } else {
            throw new Error(data.message || 'Unknown error from server');
          }
        } catch (error) {
          statusMessage.className = 'alert alert-danger';
          statusMessage.textContent = 'Error: ' + error.message;
        } finally {
          plotBtn.disabled = false;
        }
      });

      // Initial
      updatePreview();
    });
  </script>
</body>
</html>
