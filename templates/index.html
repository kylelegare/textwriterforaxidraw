<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>AxiDraw Postcard Writer</title>
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
    rel="stylesheet"
  />
  <style>
    /* Include custom font. Adjust the URL/path if needed. */
    @font-face {
      font-family: 'PremiumUltra';
      src: url('/static/fonts/PremiumUltra54.ttf') format('truetype');
    }

    #previewCanvas {
      width: 100%;
      height: auto;
      border: 1px solid var(--bs-border-color);
      background-color: white;
    }

    #fontSizeValue {
      display: inline-block;
      min-width: 40px;
      text-align: right;
    }
  </style>
</head>
<body>
  <div class="container py-4">
    <div class="row">
      <!-- Left side: Preview -->
      <div class="col-md-8">
        <div class="card mb-4">
          <div class="card-header">
            <h5 class="card-title mb-0">Postcard Preview</h5>
          </div>
          <div class="card-body">
            <canvas id="previewCanvas"></canvas>
          </div>
        </div>
      </div>

      <!-- Right side: Controls -->
      <div class="col-md-4">
        <div class="card">
          <div class="card-header">
            <h5 class="card-title mb-0">Controls</h5>
          </div>
          <div class="card-body">
            <div class="mb-3">
              <label for="messageText" class="form-label">Message</label>
              <textarea
                class="form-control"
                id="messageText"
                rows="4"
                maxlength="100"
                placeholder="Enter your message..."
              ></textarea>
            </div>

            <div class="mb-3">
              <label for="fontSize" class="form-label">Preview Size</label>
              <input
                type="range"
                class="form-range"
                id="fontSize"
                min="8"
                max="36"
                value="12"
              />
              <span id="fontSizeValue">12</span>
            </div>

            <div class="mb-3">
              <button id="plotBtn" class="btn btn-primary w-100">
                Plot Message
              </button>
            </div>
          </div>
        </div>

        <div class="card mt-4">
          <div class="card-header">
            <h5 class="card-title mb-0">Status</h5>
          </div>
          <div class="card-body">
            <div id="statusMessage" class="alert alert-info">Ready</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- JavaScript -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Dimensions for AxiDraw Mini in mm
      const AXIDRAW_WIDTH_MM = 152.4;
      const AXIDRAW_HEIGHT_MM = 101.6;
      // Convert mm to px at ~96 DPI
      const MM_TO_PX = 3.7795275591;

      // We'll store the text layout here: array of {char, x, y} in px
      let layoutData = [];

      const canvas = document.getElementById('previewCanvas');
      // Set canvas pixel dimensions to postcard size at ~96 DPI
      canvas.width = AXIDRAW_WIDTH_MM * MM_TO_PX;   
      canvas.height = AXIDRAW_HEIGHT_MM * MM_TO_PX; 

      const ctx = canvas.getContext('2d');

      const messageText = document.getElementById('messageText');
      const fontSizeRange = document.getElementById('fontSize');
      const fontSizeValue = document.getElementById('fontSizeValue');
      const plotBtn = document.getElementById('plotBtn');
      const statusMessage = document.getElementById('statusMessage');

      // We'll use an offscreen canvas to measure text
      const offscreenCanvas = document.createElement('canvas');
      const offscreenCtx = offscreenCanvas.getContext('2d');

      fontSizeRange.addEventListener('input', () => {
        fontSizeValue.textContent = fontSizeRange.value;
        updatePreview();
      });

      messageText.addEventListener('input', updatePreview);

      function updatePreview() {
        // Clear preview
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw bounding rectangle as a "safe area" margin
        // Let's say 10 mm margin on each side => 10 * MM_TO_PX
        const marginPx = 10 * MM_TO_PX;
        ctx.strokeStyle = '#ddd';
        ctx.strokeRect(
          marginPx,
          marginPx,
          canvas.width - 2 * marginPx,
          canvas.height - 2 * marginPx
        );

        // Compute text layout in px
        layoutData = computeLayout(
          messageText.value,
          parseInt(fontSizeRange.value),
          marginPx,
          marginPx,
          canvas.width - 2 * marginPx
        );

        // Render that layout onto the main preview canvas
        renderPreview(layoutData, parseInt(fontSizeRange.value));
      }

      /**
       * Word-wrap the text, returning array of {char, x, y}
       */
      function computeLayout(text, fontSizePx, startX, startY, maxWidthPx) {
        // Setup font for measuring in the offscreen canvas
        offscreenCtx.font = `${fontSizePx}px PremiumUltra`;
        offscreenCtx.textBaseline = 'top';

        const words = text.split(' ');
        const lineSpacing = fontSizePx * 1.2; // normal-ish line spacing

        // We'll track x while building each line
        let x = startX;
        let y = startY;
        let layout = [];
        let currentLine = '';
        let spaceWidth = offscreenCtx.measureText(' ').width;

        for (let i = 0; i < words.length; i++) {
          const w = words[i];
          const wordWidth = offscreenCtx.measureText(w).width;
          // If there's already text in the line, we add space + word
          const neededWidth = (currentLine === '' ? 0 : spaceWidth) + wordWidth;

          // If adding this word would exceed maxWidth, line-break
          if (x + neededWidth > startX + maxWidthPx && currentLine !== '') {
            // Lay out the entire line so far
            layout.push(...layoutLine(currentLine, offscreenCtx, fontSizePx, x, y, startX));
            // Move down to next line
            x = startX;
            y += lineSpacing;
            currentLine = w;
          } else {
            // Continue building the line
            if (currentLine === '') {
              currentLine = w;
            } else {
              currentLine += ' ' + w;
            }
            x += neededWidth;
          }
        }

        // Last line
        if (currentLine !== '') {
          layout.push(...layoutLine(currentLine, offscreenCtx, fontSizePx, x, y, startX));
        }

        return layout;
      }

      /**
       * Take a string (currentLine), measure each char, and produce array of {char, x, y}
       * We'll assume a left-to-right top baseline approach for simplicity.
       */
      function layoutLine(lineText, measureCtx, fontSizePx, endX, baselineY, lineStartX) {
        const results = [];

        // If we want left-justified text:
        //   total line width = measureCtx.measureText(lineText).width
        //   we place from lineStartX to lineStartX + totalLineWidth
        let totalWidth = measureCtx.measureText(lineText).width;
        let xPointer = lineStartX;

        // Split the line into tokens
        const tokens = lineText.split(' ');
        for (let t = 0; t < tokens.length; t++) {
          const token = tokens[t];
          for (let c = 0; c < token.length; c++) {
            const ch = token[c];
            const chWidth = measureCtx.measureText(ch).width;
            // We used textBaseline='top', so place the char at baselineY - fontSizePx if we want baseline alignment.
            // But let's just do top alignment for simplicity:
            results.push({
              char: ch,
              x: xPointer,
              y: baselineY
            });
            xPointer += chWidth;
          }
          // space after each token except last
          if (t < tokens.length - 1) {
            results.push({
              char: ' ',
              x: xPointer,
              y: baselineY
            });
            xPointer += measureCtx.measureText(' ').width;
          }
        }

        return results;
      }

      /**
       * Render the layout on previewCanvas
       */
      function renderPreview(layout, fontSizePx) {
        ctx.fillStyle = 'black';
        ctx.font = `${fontSizePx}px PremiumUltra`;
        ctx.textBaseline = 'top'; 

        layout.forEach(item => {
          ctx.fillText(item.char, item.x, item.y);
        });
      }

      /**
       * On "Plot Message", POST layout data to server
       */
      plotBtn.addEventListener('click', async () => {
        try {
          plotBtn.disabled = true;
          statusMessage.className = 'alert alert-info';
          statusMessage.textContent = 'Plotting...';

          const response = await fetch('/api/test_plot', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              layout: layoutData,
              fontSizePx: parseInt(fontSizeRange.value)
            }),
          });

          const data = await response.json();
          if (data.status === 'success') {
            statusMessage.className = 'alert alert-success';
            statusMessage.textContent = 'Plot completed!';
          } else {
            throw new Error(data.message || 'Unknown error from server');
          }
        } catch (error) {
          statusMessage.className = 'alert alert-danger';
          statusMessage.textContent = 'Error: ' + error.message;
        } finally {
          plotBtn.disabled = false;
        }
      });

      // Initial drawing
      updatePreview();
    });
  </script>
</body>
</html>
